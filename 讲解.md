# SerialFlux Pro 代码逻辑深度解析

本文档旨在帮助开发者理解 `App.jsx` 的核心架构、Web Serial API 的实现细节以及状态管理策略。

## 1. 架构概览

项目采用 **单文件组件 (Single File Component)** 架构（主要逻辑集中在 `App.jsx`），利用 React Hooks 管理状态与副作用。

### 核心模块划分：

1. **状态管理层**：使用 `useState` 和 `useRef` 管理 UI 状态和底层串口对象。
2. **持久化层**：自定义 Hook `usePersistedState` 同步配置到 LocalStorage。
3. **串口服务层**：封装 `connect`, `readLoop`, `send`, `disconnect` 等核心操作。
4. **UI 渲染层**：包含模拟窗口、模态框、侧边栏配置区和终端日志区。

## 2. 核心逻辑详解

### 2.1 串口连接与读取循环 (`readLoop`)

这是整个应用的心脏。Web Serial API 基于 **Streams API**，读取过程是一个死循环。

```
const readLoop = async (currentPort) => {
  // 1. 获取读取锁
  readerRef.current = currentPort.readable.getReader();

  try {
    while (true) {
      // 2. 异步读取数据块 (Uint8Array)
      const { value, done } = await readerRef.current.read();
      
      // 3. 检查流是否关闭
      if (done) {
        readerRef.current.releaseLock();
        break;
      }
      
      // 4. 处理数据 (如果未处于关闭中)
      if (value && !closingRef.current) {
        processIncomingData(value);
      }
    }
  } catch (error) {
    // 错误处理...
  } finally {
    // 确保释放锁，否则下次无法连接
    try { readerRef.current?.releaseLock(); } catch(e){}
  }
};
```

**关键点：**

- **readerRef**：使用 `useRef` 存储 Reader 实例，以便在组件卸载或断开连接时能强制 `cancel()` 读取流。
- **closingRef**：一个标志位 Ref。在断开连接时设为 `true`，防止在关闭过程中处理残留数据导致报错。

### 2.2 数据处理 (`processIncomingData`)

该函数负责将接收到的二进制流 (`Uint8Array`) 转换为用户可读的格式。

1. **暂停检查**：检查 `isPausedRef.current`。如果暂停，数据依然会被读取（防止硬件缓冲区溢出），但不写入 Logs 状态。

2. **解码 (Decoding)**：

   - **Hex 模式**：直接调用 `bufferToHex` 将字节转为 `AA BB` 格式字符串。
   - **ASCII 模式**：使用 `TextDecoder` (支持 UTF-8/GBK) 进行流式解码。

3. **环形缓冲 (Ring Buffer)**：

   ```
   setLogs(prev => {
       const newLogs = [...prev, newLog];
       // 限制最大行数 1000，防止内存泄漏和渲染卡顿
       if (newLogs.length > 1000) return newLogs.slice(-1000);
       return newLogs;
   });
   ```

### 2.3 数据发送 (`sendData`)

发送逻辑处理了多种情况：

1. **Hex 转换**：如果 `useHexSend` 为真，调用 `parseHexString` 清洗输入（去除非 Hex 字符）并转为 `Uint8Array`。

2. **CRC 校验**：如果开启 CRC，调用 `calculateCRC16` (Modbus 协议) 计算校验码并追加到数据末尾。

3. **行尾符**：在 ASCII 模式下，根据 `lineEnding` 设置自动追加 `\n` 或 `\r\n`。

4. **写入流**：

   ```
   const writer = port.writable.getWriter();
   await writer.write(dataToSend);
   writer.releaseLock(); // 写完立即释放，好习惯
   ```

### 2.4 数据持久化 (`usePersistedState`)

为了提升体验，我们将用户配置保存在 `localStorage` 中。

```
const usePersistedState = (key, defaultValue) => {
    // 初始化时尝试读取 LocalStorage
    const [state, setState] = useState(() => { ... });

    // 状态变化时自动写入 LocalStorage
    useEffect(() => {
        localStorage.setItem(key, JSON.stringify(state));
    }, [key, state]);

    return [state, setState];
};
```

- **安全增强**：在读取时增加了 `try-catch` 和类型检查，防止因 LocalStorage 数据损坏（如存了 `[object Object]`）导致 React 渲染崩溃（白屏）。

## 3. UI/UX 实现细节

### 3.1 模拟桌面窗口

我们没有让应用直接铺满 `body`，而是创建了一个居中的 `div` 容器：

- **层级**：`bg-zinc-900/95` + `backdrop-blur-3xl` 实现磨砂玻璃感。
- **装饰**：通过绝对定位的 `div` 模拟了四个角的螺丝孔位。
- **标题栏**：自定义了 Mac 风格的红黄绿按钮（仅作装饰），增强沉浸感。

### 3.2 解决 React 闭包陷阱

在 `readLoop` 这种长期运行的异步循环中，无法直接读取到最新的 `state`（如 `isPaused`）。 **解决方案**： 使用 `useRef` (`isPausedRef`) 来保持最新状态的引用。

```
// 1. 同步 State 到 Ref
useEffect(() => { isPausedRef.current = isPaused; }, [isPaused]);

// 2. 在循环中读取 Ref
if (isPausedRef.current) return;
```

### 3.3 虚拟列表的替代方案

虽然没有引入复杂的虚拟列表库，但我们通过：

1. **限制日志上限** (1000条)。
2. **CSS content-visibility: auto** (浏览器级渲染优化，虽然代码中未显式写出，但 Tailwind 默认行为良好)。
3. **纯文本渲染**。 保证了在数据量较大时的流畅度。

## 4. 常见问题排查 (Troubleshooting)

- **问题：无法连接串口？**
  - *原因*：浏览器不支持或未授权。
  - *解法*：确保使用 Chrome/Edge，且网站运行在 `localhost` 或 `https` 环境。
- **问题：接收全是乱码？**
  - *原因*：波特率不匹配。
  - *解法*：在右侧侧边栏修改波特率，甚至可以手动输入非标准波特率（如 74880）。
- **问题：页面刷新后配置丢失？**
  - *原因*：LocalStorage 被禁用或清空。
  - *解法*：通常情况下 `usePersistedState` 会自动处理。
- **问题：点击 Connect 没反应？**
  - *原因*：可能是上一次连接未正确释放锁。
  - *解法*：代码中已加入 `closingRef` 和 `releaseLock` 保护，但极端情况下刷新页面即可重置。